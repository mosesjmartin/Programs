/* Directed Acyclic Graph (DAG) */

#include<stdio.h>
#include<string.h>
#include<ctype.h>
#include<malloc.h>
int main()
{
 char s[20],a[20],op[4]={'*','/','+','-'};
 int l,i,j,k,p,*flag,x,y[20][3];
 printf("\nEnter the Expression: ");
 scanf("%s",s);
 l=strlen(s);
 flag=(int *)calloc(l,sizeof(int));
 for(i=0,j=0;i<l;i++)
 {
  if(isalpha(s[i]))
  {
   a[j]=s[i];
   y[j][1]=0;
   y[j][2]=0;
   y[j][3]=i;
   j++;
  }
 }
 x=0;
 for(i=0;i<l;i++)
 {
  if(s[i]=='(')
  {
   flag[i]=1;
   for(p=i+1;p<l&&s[p]!=')';)
   {
    if(s[p]==op[0]||s[p]==op[1])
    {
     if(flag[p]==1)
      continue;
     a[j]=s[p];
     y[j][3]=p;
     for(k=p-1;k>i;k--)
     {
      if(flag[k]==0)
      {
       for(x=0;x<j;x++)
        if(k==y[x][3])
        {
         y[j][1]=x+1;
         break;
        }
       flag[k]=1;
       break;
      }
     }
     for(k=p+1;k<l&&s[k]!=')';k++)
     {
      if(flag[k]==0)
      {
       for(x=0;x<j;x++)
        if(k==y[x][3])
        {
         y[j][2]=x+1;
         break;
        }
       flag[k]=1;
       break;
      }
     }
     j++;
    }
    p++;
   }
   for(p=i+1;p<l&&s[p]!=')';)
   {
    if(s[p]==op[2]||s[p]==op[3])
    {
     if(flag[p]==1)
      continue;
     a[j]=s[p];
     y[j][3]=p;
     for(k=p-1;k>i;k--)
     {
      if(flag[k]==0)
      {
       for(x=0;x<j;x++)
        if(k==y[x][3])
        {
         y[j][1]=x+1;
         break;
        }
       flag[k]=1;
       break;
      }
     }
     for(k=p+1;k<l&&s[k]!='(';k++)
     {
      if(flag[k]==0)
      {
       for(x=0;x<j;x++)
       {
        if(k==y[x][3])
        {
         y[j][2]=x+1;
         break;
        }
       }
       flag[k]=1;
       break;
      }
     }
     j++;
    }
    p++;
   }
   flag[p]=1;
   i=p+1;
  }
  else
   i++;
 }
 for(i=0;i<l;)
 {
  if(s[i]=='(')
   while(s[i]!=')')
   {
    i++;
   }
  if(s[i]==op[0]||s[i]==op[1])
  {
   a[j]=s[i];
   y[j][3]=i;
   for(k=i-1;k>=0;k--)
   {
    if(flag[k]==0)
    {
     for(x=0;x<j;x++)
      if(k==y[x][3])
      {
       y[j][1]=x+1;
       break;
      }
     flag[k]=1;
     break;
    }
   }
   for(k=i+1;k<l;k++)
   {
    if(flag[k]==0)
    {
     for(x=0;x<j;x++)
      if(k==y[x][3])
      {
       y[j][2]=x+1;
       break;
      }
     flag[k]=1;
     break;
    }
   }
   j++;
   i++;
  }
  else
   i++;
 }
 for(i=0;i<l;)
 {
  if(s[i]=='(')
   while(s[i]!=')')
   {
    i++;
   }
  if(s[i]==op[2]||s[i]==op[3])
  {
   a[j]=s[i];
   y[j][3]=i;
   for(k=i-1;k>=0;k--)
   {
    if(flag[k]==0)
    {
     for(x=0;x<j;x++)
      if(k==y[x][3])
      {
       y[j][1]=x+1;
       break;
      }
     flag[k]=1;
     break;
    }
   }
   for(k=i+1;k<l;k++)
   {
    if(flag[k]==0)
    {
     for(x=0;x<j;x++)
      if(k==y[x][3])
      {
       y[j][2]=x+1;
       break;
      }
     flag[k]=1;
     break;
    }
   }
   j++;
   i++;
  }
  else
   i++;
 }
 printf("\nActual Table:\n");
 for(i=0;i<j;i++)
  printf("%d\t%c\t%d\t%d\n",i+1,a[i],y[i][1],y[i][2]);
 for(i=0;i<j;i++)
 {
  if(a[i]=='0')
   continue;
  for(k=i+1;k<j;k++)
  {
   if(a[k]=='0')
    continue;
   if(a[i]==a[k]&&y[i][1]==y[k][1]&&y[i][2]==y[k][2])
   {
    a[k]='0';
    for(x=0;x<j;x++)
    {
     if(y[x][1]==k+1)
      y[x][1]=i+1;
     if(y[x][2]==k+1)
      y[x][2]=i+1;
    }
   }
  }
 }
 k=0;
 for(i=0;i<j;i++)
 {
  if(a[i]=='0')
   continue;
  else
  {
    y[i][3]=k+1;
    for(x=0;x<j;x++)
    {
     if(y[x][1]==i+1)
      y[x][1]=k+1;
     if(y[x][2]==i+1)
      y[x][2]=k+1;
    }
    k++;
  }
 }
 printf("\nDAG Table:\n");
 for(i=0;i<j;i++)
 {
  if(a[i]=='0')
   continue;
  printf("%d\t%c\t%d\t%d\n",y[i][3],a[i],y[i][1],y[i][2]);
 }
 return 0;
}
